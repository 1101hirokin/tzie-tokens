import StyleDictionary from "style-dictionary";
import {
  groupTokensBySource,
  normalizePath,
  aliasElevationLayer,
} from "./transforms.js";

// Register all custom formats
export const registerFormats = () => {
  // CSS format
  StyleDictionary.registerFormat({
    name: "css/unified-themes",
    format: ({ dictionary, options }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const formatVar = (token) => {
        let value = token.$value;
        const type = token.$type || token.type;
        const origValue = token.original?.$value;

        // Handle cubicBezier type for CSS - use original array value
        if (type === "cubicBezier" && Array.isArray(origValue)) {
          value = `cubic-bezier(${origValue.join(", ")})`;
        } else if (type === "duration" && typeof value === "number") {
          value = `${value}ms`;
        } else if (
          options.outputReferences &&
          typeof origValue === "string" &&
          origValue.includes("{")
        ) {
          value = origValue.replace(/\{([^}]+)\}/g, (_, refPath) => {
            const refName = normalizePath(
              aliasElevationLayer(refPath.split(".")),
              "kebab"
            );
            return `var(--tz-${refName})`;
          });
        }
        return `  --${token.name}: ${value};`;
      };

      let output =
        "/**\n * Design Tokens\n * Generated by Style Dictionary\n */\n\n";

      // CLI mode: output theme tokens as :root[data-theme]
      if (options.themeOnly) {
        Object.keys(themeTokensByName)
          .sort()
          .forEach((name) => {
            const tokens = themeTokensByName[name];
            if (tokens.length) {
              output += `:root[data-theme="${name}"] {\n${tokens.map(formatVar).join("\n")}\n}\n`;
            }
          });
      } else {
        // Default mode: base in :root, themes in :root[data-theme]
        if (baseTokens.length) {
          output +=
            ":root {\n" + baseTokens.map(formatVar).join("\n") + "\n}\n";
        }
        Object.keys(themeTokensByName)
          .sort()
          .forEach((name) => {
            const tokens = themeTokensByName[name];
            if (tokens.length) {
              output += `\n:root[data-theme="${name}"] {\n${tokens.map(formatVar).join("\n")}\n}\n`;
            }
          });
      }
      return output;
    },
  });

  // JSON format
  StyleDictionary.registerFormat({
    name: "json/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const buildTree = (tokens) =>
        tokens.reduce((tree, token) => {
          const path = [...token.path];
          const lastKey = path.pop();
          path.reduce((obj, key) => (obj[key] ??= {}), tree)[lastKey] =
            token.$value;
          return tree;
        }, {});

      return JSON.stringify(
        {
          base: buildTree(baseTokens),
          themes: Object.fromEntries(
            Object.keys(themeTokensByName)
              .sort()
              .map((name) => [name, buildTree(themeTokensByName[name])])
          ),
        },
        null,
        2
      );
    },
  });

  // JavaScript format
  StyleDictionary.registerFormat({
    name: "javascript/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const formatValue = (token) => {
        const value = token.$value;
        const type = token.$type || token.type;
        const origValue = token.original?.$value;

        if (type === "fontFamily")
          return `"${value.replace(/"/g, '\\"')}"`;
        if (type === "cubicBezier" && Array.isArray(origValue)) {
          return `[${origValue.join(", ")}]`;
        }
        if (Array.isArray(value)) {
          return `[${value.join(", ")}]`;
        }
        return typeof value === "string" ? `"${value}"` : value;
      };

      let output = "export const base = {\n";
      output += baseTokens
        .map((t) => `  ${t.name}: ${formatValue(t)},`)
        .join("\n");
      output += "\n};\n\nexport const themes = {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const tokens = themeTokensByName[name]
            .map((t) => `    ${t.name}: ${formatValue(t)},`)
            .join("\n");
          return `  "${name}": {\n${tokens}\n  },`;
        })
        .join("\n");
      output += "\n};\n";
      return output;
    },
  });

  // iOS Swift format
  StyleDictionary.registerFormat({
    name: "ios-swift/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);

      // Separate cubicBezier tokens from others
      const baseCubicBezier = baseTokens.filter(
        (t) => (t.$type || t.type) === "cubicBezier"
      );
      const baseOther = baseTokens.filter(
        (t) => (t.$type || t.type) !== "cubicBezier"
      );

      const formatValue = (token) => {
        const value = token.$value;
        const type = token.$type || token.type;

        if (type === "fontFamily" && typeof value === "string") {
          return `"${value.replace(/"/g, '\\"')}"`;
        }
        if (
          type === "fontWeight" &&
          (typeof value === "string" || typeof value === "number")
        ) {
          return String(value);
        }
        return value;
      };

      let output = "import UIKit\nimport SwiftUI\n\npublic enum DesignTokens {\n";
      output += "  public enum Base {\n";
      output +=
        baseOther
          .map((t) => `    public static let ${t.name} = ${formatValue(t)}`)
          .join("\n") + "\n";
      output += "  }\n\n  public enum Themes {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const tokens = themeTokensByName[name].filter(
            (t) => (t.$type || t.type) !== "cubicBezier"
          );
          const tokensStr = tokens
            .map(
              (t) => `      public static let ${t.name} = ${formatValue(t)}`
            )
            .join("\n");
          return `    public enum ${name.replace(/-/g, "_")} {\n${tokensStr}\n    }`;
        })
        .join("\n");
      output += "\n  }\n}\n";

      // Add Animation extension for cubicBezier tokens
      if (baseCubicBezier.length > 0) {
        output += "\nextension Animation {\n";
        baseCubicBezier.forEach((token) => {
          const origValue = token.original?.$value;
          if (Array.isArray(origValue) && origValue.length === 4) {
            const propName = token.name.replace(/^tz/, "");
            output += `  public static var ${propName}: Animation {\n`;
            output += `    .timingCurve(${origValue.join(", ")})\n`;
            output += `  }\n`;
          }
        });
        output += "}\n";
      }

      return output;
    },
  });

  // TypeScript definitions format
  StyleDictionary.registerFormat({
    name: "typescript/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);

      const formatType = (token) => {
        const type = token.$type || token.type;
        const origValue = token.original?.$value;

        if (type === "cubicBezier" && Array.isArray(origValue)) {
          return `readonly [${origValue.join(", ")}]`;
        }
        if (type === "fontFamily") {
          return "string";
        }
        if (type === "duration") {
          return "number";
        }
        if (type === "color") {
          return "string";
        }
        if (type === "dimension") {
          return "string";
        }
        if (typeof token.$value === "string") {
          return "string";
        }
        if (typeof token.$value === "number") {
          return "number";
        }
        return "any";
      };

      let output = "export declare const base: {\n";
      output += baseTokens
        .map((t) => `  readonly ${t.name}: ${formatType(t)};`)
        .join("\n");
      output += "\n};\n\n";

      output += "export declare const themes: {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const tokens = themeTokensByName[name]
            .map((t) => `    readonly ${t.name}: ${formatType(t)};`)
            .join("\n");
          return `  readonly "${name}": {\n${tokens}\n  };`;
        })
        .join("\n");
      output += "\n};\n";

      return output;
    },
  });

  // Compose format
  StyleDictionary.registerFormat({
    name: "compose/themed",
    format: ({ dictionary, options }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);

      // Separate cubicBezier tokens from others
      const baseCubicBezier = baseTokens.filter(
        (t) => (t.$type || t.type) === "cubicBezier"
      );
      const baseOther = baseTokens.filter(
        (t) => (t.$type || t.type) !== "cubicBezier"
      );

      const formatValue = (token) => {
        let value = token.$value || token.value;
        const type = token.$type || token.type;

        if (type === "fontFamily" && typeof value === "string") {
          return `"${value.replace(/"/g, '\\"')}"`;
        }

        if (type === "fontWeight") {
          return String(value);
        }

        if (typeof value === "string" && value.endsWith(".dp")) {
          const name = (token.name || "").toLowerCase();
          if (name.includes("fontsize") || name.includes("lineheight")) {
            value = value.replace(/\.dp$/, ".sp");
          }
        }
        return value;
      };

      let output = `package ${options.packageName || "com.example.tokens"}\n\n`;
      output +=
        "import androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\n";

      // Add CubicBezierEasing import if needed
      if (baseCubicBezier.length > 0) {
        output += "import androidx.compose.animation.core.CubicBezierEasing\n";
      }

      output += "\nobject DesignTokens {\n  object Base {\n";
      output +=
        baseOther.map((t) => `    val ${t.name} = ${formatValue(t)}`).join("\n") +
        "\n";
      output += "  }\n\n  object Themes {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const objName = name
            .split("-")
            .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
            .join("");
          const tokens = themeTokensByName[name].filter(
            (t) => (t.$type || t.type) !== "cubicBezier"
          );
          const tokensStr = tokens
            .map((t) => `      val ${t.name} = ${formatValue(t)}`)
            .join("\n");
          return `    object ${objName} {\n${tokensStr}\n    }`;
        })
        .join("\n");
      output += "\n  }\n}\n";

      // Add MotionEasing object for cubicBezier tokens
      if (baseCubicBezier.length > 0) {
        output += "\nobject MotionEasing {\n";
        baseCubicBezier.forEach((token) => {
          const origValue = token.original?.$value;
          if (Array.isArray(origValue) && origValue.length === 4) {
            const propName = token.name
              .replace(/^tz/, "")
              .split(/(?=[A-Z])/)
              .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
              .join("");
            const floatValues = origValue.map((v) => `${v}f`).join(", ");
            output += `  val ${propName} = CubicBezierEasing(${floatValues})\n`;
          }
        });
        output += "}\n";
      }

      return output;
    },
  });
};
