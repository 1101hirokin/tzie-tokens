import StyleDictionary from "style-dictionary";
import {
  groupTokensBySource,
  normalizePath,
  aliasElevationLayer,
} from "./transforms.js";

// Register all custom formats
export const registerFormats = () => {
  // CSS format
  StyleDictionary.registerFormat({
    name: "css/unified-themes",
    format: ({ dictionary, options }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const formatVar = (token) => {
        let value = token.$value;
        const origValue = token.original?.$value;
        if (
          options.outputReferences &&
          typeof origValue === "string" &&
          origValue.includes("{")
        ) {
          value = origValue.replace(/\{([^}]+)\}/g, (_, refPath) => {
            const refName = normalizePath(
              aliasElevationLayer(refPath.split(".")),
              "kebab"
            );
            return `var(--tz-${refName})`;
          });
        }
        return `  --${token.name}: ${value};`;
      };

      let output =
        "/**\n * Design Tokens\n * Generated by Style Dictionary\n */\n\n";

      // CLI mode: output theme tokens as :root
      if (options.themeOnly) {
        Object.keys(themeTokensByName)
          .sort()
          .forEach((name) => {
            const tokens = themeTokensByName[name];
            if (tokens.length) {
              output += `:root {\n${tokens.map(formatVar).join("\n")}\n}\n`;
            }
          });
      } else {
        // Default mode: base in :root, themes in :root[data-theme]
        if (baseTokens.length) {
          output +=
            ":root {\n" + baseTokens.map(formatVar).join("\n") + "\n}\n";
        }
        Object.keys(themeTokensByName)
          .sort()
          .forEach((name) => {
            const tokens = themeTokensByName[name];
            if (tokens.length) {
              output += `\n:root[data-theme="${name}"] {\n${tokens.map(formatVar).join("\n")}\n}\n`;
            }
          });
      }
      return output;
    },
  });

  // JSON format
  StyleDictionary.registerFormat({
    name: "json/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const buildTree = (tokens) =>
        tokens.reduce((tree, token) => {
          const path = [...token.path];
          const lastKey = path.pop();
          path.reduce((obj, key) => (obj[key] ??= {}), tree)[lastKey] =
            token.$value;
          return tree;
        }, {});

      return JSON.stringify(
        {
          base: buildTree(baseTokens),
          themes: Object.fromEntries(
            Object.keys(themeTokensByName)
              .sort()
              .map((name) => [name, buildTree(themeTokensByName[name])])
          ),
        },
        null,
        2
      );
    },
  });

  // JavaScript format
  StyleDictionary.registerFormat({
    name: "javascript/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const formatValue = (token) => {
        const value = token.$value;
        const type = token.$type || token.type;
        if (type === "fontFamily")
          return `"${value.replace(/"/g, '\\"')}"`;
        return typeof value === "string" ? `"${value}"` : value;
      };

      let output = "export const base = {\n";
      output += baseTokens
        .map((t) => `  ${t.name}: ${formatValue(t)},`)
        .join("\n");
      output += "\n};\n\nexport const themes = {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const tokens = themeTokensByName[name]
            .map((t) => `    ${t.name}: ${formatValue(t)},`)
            .join("\n");
          return `  "${name}": {\n${tokens}\n  },`;
        })
        .join("\n");
      output += "\n};\n";
      return output;
    },
  });

  // iOS Swift format
  StyleDictionary.registerFormat({
    name: "ios-swift/themed",
    format: ({ dictionary }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const formatValue = (token) => {
        const value = token.$value;
        const type = token.$type || token.type;

        if (type === "fontFamily" && typeof value === "string") {
          return `"${value.replace(/"/g, '\\"')}"`;
        }
        if (
          type === "fontWeight" &&
          (typeof value === "string" || typeof value === "number")
        ) {
          return String(value);
        }
        return value;
      };

      let output = "import UIKit\n\npublic enum DesignTokens {\n";
      output += "  public enum Base {\n";
      output +=
        baseTokens
          .map((t) => `    public static let ${t.name} = ${formatValue(t)}`)
          .join("\n") + "\n";
      output += "  }\n\n  public enum Themes {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const tokens = themeTokensByName[name]
            .map(
              (t) => `      public static let ${t.name} = ${formatValue(t)}`
            )
            .join("\n");
          return `    public enum ${name.replace(/-/g, "_")} {\n${tokens}\n    }`;
        })
        .join("\n");
      output += "\n  }\n}\n";
      return output;
    },
  });

  // Compose format
  StyleDictionary.registerFormat({
    name: "compose/themed",
    format: ({ dictionary, options }) => {
      const { baseTokens, themeTokensByName } =
        groupTokensBySource(dictionary.allTokens);
      const formatValue = (token) => {
        let value = token.$value || token.value;
        const type = token.$type || token.type;

        if (type === "fontFamily" && typeof value === "string") {
          return `"${value.replace(/"/g, '\\"')}"`;
        }

        if (type === "fontWeight") {
          return String(value);
        }

        if (typeof value === "string" && value.endsWith(".dp")) {
          const name = (token.name || "").toLowerCase();
          if (name.includes("fontsize") || name.includes("lineheight")) {
            value = value.replace(/\.dp$/, ".sp");
          }
        }
        return value;
      };

      let output = `package ${options.packageName || "com.example.tokens"}\n\n`;
      output +=
        "import androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\n\n";
      output += "object DesignTokens {\n  object Base {\n";
      output +=
        baseTokens.map((t) => `    val ${t.name} = ${formatValue(t)}`).join("\n") +
        "\n";
      output += "  }\n\n  object Themes {\n";
      output += Object.keys(themeTokensByName)
        .sort()
        .map((name) => {
          const objName = name
            .split("-")
            .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
            .join("");
          const tokens = themeTokensByName[name]
            .map((t) => `      val ${t.name} = ${formatValue(t)}`)
            .join("\n");
          return `    object ${objName} {\n${tokens}\n    }`;
        })
        .join("\n");
      output += "\n  }\n}\n";
      return output;
    },
  });
};
