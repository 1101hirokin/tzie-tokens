import StyleDictionary from "style-dictionary";
import { register as registerTokensStudio, expandTypesMap } from "@tokens-studio/sd-transforms";

registerTokensStudio(StyleDictionary);

// elevation layer (0/1 → core, 2 → cast) の変換
const aliasElevationLayer = (path) => {
    const p = path.map(String);
    const idx = p.indexOf("elevation");
    if (idx === -1 || p.length <= idx + 2) return p;
    const layer = p[idx + 2];
    const alias = (layer === "0" || layer === "1") ? "core" : layer === "2" ? "cast" : null;
    if (!alias) return p;
    const cloned = [...p];
    cloned[idx + 2] = alias;
    return cloned;
};

// path を正規化して case 変換する共通関数
const normalizePath = (path, toCase) => {
    const normalized = path.map((seg) =>
        String(seg).replace(/[^a-zA-Z0-9]+/g, " ").toLowerCase().split(" ").filter(Boolean)
    ).flat();

    if (toCase === "kebab") {
        return normalized.join("-");
    }
    // camelCase
    return normalized.map((s, i) => i === 0 ? s : s.charAt(0).toUpperCase() + s.slice(1)).join("");
};

// Name transforms
["kebab", "camel"].forEach((caseType) => {
    StyleDictionary.registerTransform({
        name: `name/${caseType}-elevation-layer`,
        type: "name",
        transform: (token, options) => {
            const name = normalizePath(aliasElevationLayer(token.path), caseType);
            const prefix = options?.prefix;
            if (!prefix) return name;
            return caseType === "kebab" ? `${prefix}-${name}` : `${prefix}${name.charAt(0).toUpperCase()}${name.slice(1)}`;
        },
    });
});

// Dimension transforms (dimension タイプの px 値のみ対象)
["swift/cgfloat", "compose/dp"].forEach((name) => {
    StyleDictionary.registerTransform({
        name: `size/${name}`,
        type: "value",
        matcher: (token) => {
            const type = token.$type || token.type;
            const value = token.$value || token.value;

            // Only process dimension type
            if (type !== "dimension") {
                return false;
            }

            // For strings, ONLY match if it's a valid px string
            if (typeof value === "string") {
                const trimmed = value.trim();
                if (!trimmed.endsWith("px")) return false;
                const num = parseFloat(trimmed);
                return !isNaN(num) && isFinite(num);
            }

            // For numbers, make sure they're valid
            if (typeof value === "number") {
                return !isNaN(value) && isFinite(value);
            }

            return false;
        },
        transform: (token) => {
            const type = token.$type || token.type;
            const value = token.$value || token.value;

            // Safety check: only transform dimension types
            if (type !== "dimension") {
                return value;
            }

            const num = typeof value === "string" ? parseFloat(value) : value;
            return name === "swift/cgfloat" ? `CGFloat(${num})` : `${num}.dp`;
        },
    });
});

// base/theme グループ化
const groupTokensBySource = (allTokens) => {
    const baseTokens = [];
    const themeTokensByName = {};

    allTokens.forEach((token) => {
        const filePath = token.filePath || "";
        if (filePath.includes("base.tokens.json")) {
            baseTokens.push(token);
        } else if (filePath.includes("src/theme/")) {
            const themeName = filePath.match(/src\/theme\/(.+)\.json$/)?.[1];
            if (themeName) {
                (themeTokensByName[themeName] ??= []).push(token);
            }
        }
    });

    return { baseTokens, themeTokensByName };
};

// CSS format
StyleDictionary.registerFormat({
    name: "css/unified-themes",
    format: ({ dictionary, options }) => {
        const { baseTokens, themeTokensByName } = groupTokensBySource(dictionary.allTokens);
        const formatVar = (token) => {
            let value = token.$value;
            const origValue = token.original?.$value;
            if (options.outputReferences && typeof origValue === "string" && origValue.includes("{")) {
                value = origValue.replace(/\{([^}]+)\}/g, (_, refPath) => {
                    const refName = normalizePath(aliasElevationLayer(refPath.split(".")), "kebab");
                    return `var(--tz-${refName})`;
                });
            }
            return `  --${token.name}: ${value};`;
        };

        let output = "/**\n * Design Tokens\n * Generated by Style Dictionary\n */\n\n";
        if (baseTokens.length) {
            output += ":root {\n" + baseTokens.map(formatVar).join("\n") + "\n}\n";
        }
        Object.keys(themeTokensByName).sort().forEach((name) => {
            const tokens = themeTokensByName[name];
            if (tokens.length) {
                output += `\n:root[data-theme="${name}"] {\n` + tokens.map(formatVar).join("\n") + "\n}\n";
            }
        });
        return output;
    },
});

// JSON format
StyleDictionary.registerFormat({
    name: "json/themed",
    format: ({ dictionary }) => {
        const { baseTokens, themeTokensByName } = groupTokensBySource(dictionary.allTokens);
        const buildTree = (tokens) => tokens.reduce((tree, token) => {
            const path = [...token.path];
            const lastKey = path.pop();
            path.reduce((obj, key) => obj[key] ??= {}, tree)[lastKey] = token.$value;
            return tree;
        }, {});

        return JSON.stringify({
            base: buildTree(baseTokens),
            themes: Object.fromEntries(
                Object.keys(themeTokensByName).sort().map((name) => [name, buildTree(themeTokensByName[name])])
            ),
        }, null, 2);
    },
});

// JavaScript format
StyleDictionary.registerFormat({
    name: "javascript/themed",
    format: ({ dictionary }) => {
        const { baseTokens, themeTokensByName } = groupTokensBySource(dictionary.allTokens);
        const formatValue = (token) => {
            const value = token.$value;
            const type = token.$type || token.type;
            // fontFamily value is already a quoted string, wrap once more for JS
            if (type === "fontFamily") return `"${value.replace(/"/g, '\\"')}"`;
            return typeof value === "string" ? `"${value}"` : value;
        };

        let output = "export const base = {\n";
        output += baseTokens.map((t) => `  ${t.name}: ${formatValue(t)},`).join("\n");
        output += "\n};\n\nexport const themes = {\n";
        output += Object.keys(themeTokensByName).sort().map((name) => {
            const tokens = themeTokensByName[name].map((t) => `    ${t.name}: ${formatValue(t)},`).join("\n");
            return `  "${name}": {\n${tokens}\n  },`;
        }).join("\n");
        output += "\n};\n";
        return output;
    },
});

// iOS Swift format
StyleDictionary.registerFormat({
    name: "ios-swift/themed",
    format: ({ dictionary }) => {
        const { baseTokens, themeTokensByName } = groupTokensBySource(dictionary.allTokens);
        const formatValue = (token) => {
            const value = token.$value;
            const type = token.$type || token.type;

            // Handle different token types appropriately
            if (type === "fontFamily" && typeof value === "string") {
                return `"${value.replace(/"/g, '\\"')}"`;
            }
            if (type === "fontWeight" && (typeof value === "string" || typeof value === "number")) {
                return String(value);
            }
            return value;
        };

        let output = "import UIKit\n\npublic enum DesignTokens {\n";
        output += "  public enum Base {\n";
        output += baseTokens.map((t) => `    public static let ${t.name} = ${formatValue(t)}`).join("\n") + "\n";
        output += "  }\n\n  public enum Themes {\n";
        output += Object.keys(themeTokensByName).sort().map((name) => {
            const tokens = themeTokensByName[name].map((t) => `      public static let ${t.name} = ${formatValue(t)}`).join("\n");
            return `    public enum ${name.replace(/-/g, "_")} {\n${tokens}\n    }`;
        }).join("\n");
        output += "\n  }\n}\n";
        return output;
    },
});

// Compose format
StyleDictionary.registerFormat({
    name: "compose/themed",
    format: ({ dictionary, options }) => {
        const { baseTokens, themeTokensByName } = groupTokensBySource(dictionary.allTokens);
        const formatValue = (token) => {
            let value = token.$value || token.value;
            const type = token.$type || token.type;

            // Handle fontFamily: wrap in quotes for Kotlin
            if (type === "fontFamily" && typeof value === "string") {
                return `"${value.replace(/"/g, '\\"')}"`;
            }

            // Handle fontWeight: return as-is (number)
            if (type === "fontWeight") {
                return String(value);
            }

            // fontSize/lineHeight は .sp に変換
            if (typeof value === "string" && value.endsWith(".dp")) {
                const name = (token.name || "").toLowerCase();
                if (name.includes("fontsize") || name.includes("lineheight")) {
                    value = value.replace(/\.dp$/, ".sp");
                }
            }
            return value;
        };

        let output = `package ${options.packageName || "com.example.tokens"}\n\n`;
        output += "import androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\n\n";
        output += "object DesignTokens {\n  object Base {\n";
        output += baseTokens.map((t) => `    val ${t.name} = ${formatValue(t)}`).join("\n") + "\n";
        output += "  }\n\n  object Themes {\n";
        output += Object.keys(themeTokensByName).sort().map((name) => {
            const objName = name.split("-").map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join("");
            const tokens = themeTokensByName[name].map((t) => `      val ${t.name} = ${formatValue(t)}`).join("\n");
            return `    object ${objName} {\n${tokens}\n    }`;
        }).join("\n");
        output += "\n  }\n}\n";
        return output;
    },
});

export default {
    source: ["src/**/*.json"],
    preprocessors: ["tokens-studio"],
    platforms: {
        json: {
            prefix: "tz",
            transformGroup: "tokens-studio",
            buildPath: "dist/json/",
            files: [{ destination: "tokens.json", format: "json/themed" }],
        },
        js: {
            prefix: "tz",
            transformGroup: "tokens-studio",
            transforms: ["name/camel-elevation-layer"],
            buildPath: "dist/js/",
            expand: { typesMap: expandTypesMap, include: ["typography", "shadow"] },
            files: [{ destination: "tokens.js", format: "javascript/themed" }],
        },
        css: {
            prefix: "tz",
            transformGroup: "tokens-studio",
            transforms: ["name/kebab-elevation-layer"],
            buildPath: "dist/css/",
            files: [{
                destination: "tokens.css",
                format: "css/unified-themes",
                options: { outputReferences: true },
            }],
        },
        compose: {
            prefix: "tz",
            transformGroup: "tokens-studio",
            transforms: ["name/camel-elevation-layer", "color/composeColor", "size/compose/dp"],
            buildPath: "dist/compose/",
            expand: { typesMap: expandTypesMap, include: ["typography", "shadow"] },
            files: [{
                destination: "Tokens.kt",
                format: "compose/themed",
                options: { packageName: "com.tzie.tokens" },
            }],
        },
        iosSwift: {
            prefix: "tz",
            transformGroup: "tokens-studio",
            transforms: ["name/camel-elevation-layer", "color/UIColorSwift", "content/swift/literal", "asset/swift/literal", "size/swift/cgfloat"],
            buildPath: "dist/ios/",
            expand: { typesMap: expandTypesMap, include: ["typography", "shadow"] },
            files: [{ destination: "DesignTokens.swift", format: "ios-swift/themed" }],
        },
    },
};
